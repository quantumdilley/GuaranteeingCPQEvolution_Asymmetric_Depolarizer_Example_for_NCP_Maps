(* ::Package:: *)

(* ::Input:: *)
(*BeginPackage["quantum`"]*)
(**)
(*pm::usage= "pm[INDEX] is a simplification of the function PauliMatrix[INDEX].";*)
(*plus::usage= "plus[\[Epsilon]] is the coefficient on the identity in our definition of a weak measurement.";*)
(*minus::usage= "minus[\[Epsilon]] is the coefficient on the direction n\[CenterDot]\[Sigma] in our definition of a weak measurement.";*)
(*measure::usage= "measure[\[Epsilon],x,y,z] is our definition of a weak measurement on a single qubit in the unit direction {x,y,z}.";*)
(*pauli::usage= "pauli represents the vector of Pauli matrices given by {PauliMatrix[1],PauliMatrix[2],PauliMatrix[3]}.";*)
(*kp::usage= "kp[MATRIX1,MATRIX2] is a simplification of the function KroneckerProduct[MATRIX1,MATRIX2]";*)
(*pt1::usage= "pt1[STATE] traces out the second system and gives the state of the first qubit";*)
(*pt2::usage= "pt2[STATE] traces out the first system and gives the state of the second qubit";*)
(*pTran::usage= "pTran[STATE] takes the partial transpose of the second system of a two-qubit state";*)
(*density::usage= "density[x,y,z] gives the 2x2 operator representing the state of a single qubit with a Bloch vector of {x,y,z}.";*)
(*bloch::usage= "bloch[STATE] gives the Bloch vector of the single qubit state STATE.";*)
(*a2b::usage= "a2b[4x4_MATRIX] interchanges the A and B-matrices, where the B-matrix has eigenvectors and eigenvalues that make up the operator-sum decomposition of a single qubit channel";*)
(*d2v::usage= "d2v[DENSITY_OPERATOR] gives the 1x4 column vector representation of a single qubit density operator.";*)
(*v2d::usage= "v2d[4x1_VECTOR] gives the ordinary 2x2 density form of a single qubit state.";*)
(*d2vTwoQubit::usage= "d2vTwoQubit[DENSITY_OPERATOR] gives the 1x16 column vector representation of a two-qubit density operator.";*)
(*v2dTwoQubit::usage= "d2vTwoQubit[DENSITY_OPERATOR] gives the ordinary 4x4 density form of a two-qubit state.";*)
(*vecShift::usage= "vecShift[A_MATRIX] denotes the changing in vectorizations methods. Applying this rotation on A_1 \[CircleTimes] A_2 gives the actual A-matrix of A_1 \[CircleTimes] A_2 that allows us to use Flatten on our two-qubit state for the vectorization; i.e., vecShift[A_1 \[CircleTimes] A_2].Flatten[\[Rho]^{AB}] is correct.";*)
(*convert::usage= "convert[A_MATRIX,DIMENSION_OF_STATE] gives the transformation from A to B matrix and vice versa. Input either the A-matrix or B-matrix and then the dimension of the state that the A-matrix acts on. For instance, if the A-matrix is 4\[Cross]4, then dimension is 2 and if the A-matrix is 16\[Cross]16, then dimension is 4.";*)
(*zz::usage= "zz represents the |0><0| state in density form given by {{1,0},{0,0}}.";*)
(*zo::usage= "zo represents the |0><1| state in density form given by {{0,1},{0,0}}.";*)
(*oz::usage= "oz represents the |1><0| state in density form given by {{0,0},{1,0}}.";*)
(*oo::usage= "oo represents the |1><1| state in density form given by {{0,0},{0,1}}.";*)
(*phiP::usage= "phiP gives the maximally entangled Bell state 1/Sqrt[2](|00>+|11>) in 4x4 matrix form.";*)
(*phiM::usage= "phiM gives the maximally entangled Bell state 1/Sqrt[2](|00>-|11>) in 4x4 matrix form.";*)
(*psiP::usage= "psiP gives the maximally entangled Bell state 1/Sqrt[2](|01>+|10>) in 4x4 matrix form.";*)
(*psiM::usage= "psiM gives the maximally entangled Bell state 1/Sqrt[2](|01>-|10>) in 4x4 matrix form.";*)
(*hadamard::usage= "hadamard represents the 2x2 hadamard operator.";*)
(*swap::usage= "swap represents the quantum gate SWAP.";*)
(*cnot12::usage= "cnot12 represents the controlled NOT quantum gate, with the second qubit being the target.";*)
(*cnot21::usage= "cnot21 represents the controlled NOT quantum gate, with the first qubit being the target.";*)
(*state::usage= "state[VECTOR_1,VECTOR_2,CORRELATION_MATRIX] gives an arbitrary two-qubit state where the first particle has a Bloch vector VECTOR_1, the second particle has a Bloch vector VECTOR_2, and the correlations between the two particles are given by the 3x3 correlation matrix CORRELATION_MATRIX.";*)
(*unitary::usage= "unitary[STATE,UNITARY] rotates STATE by UNITARY; giving the representation U.\[Rho].ConjugateTranspose[U].";*)
(*cUnitary12::usage= "cUnitary[\[Theta],x,y,z] gives the controlled untary operation with the control on the first qubit and the target on the second qubit. The rotation is counter-clockwise about the unit vector {x,y,z} by an angle \[Theta].";*)
(*cUnitary21::usage= "cUnitary[\[Theta],x,y,z] gives the controlled untary operation with the control on the second qubit and the target on the first qubit. The rotation is counter-clockwise about the unit vector {x,y,z} by an angle \[Theta].";*)
(*asym::usage= "asym[\[Alpha],\[Beta],\[Gamma]] represents the 4x4 A matrix of the assymetric depolarizer for a single qubit. The Bloch vector components x, y, and z are shrunk by the respective paramters \[Alpha], \[Beta], and \[Gamma].";*)
(*asymChannel::usage= "asymChannel[STATE,\[Alpha],\[Beta],\[Gamma]] runs the first particle of a two-qubit state STATE through the asymmetric depolarizer. The Bloch vector components x, y, and z of the first particle are shrunk by the respective paramters \[Alpha], \[Beta], and \[Gamma]; while the state of the second particle is left unchanged.";*)
(*translate::usage= "translate[x0,y0,z0] gives the single qubit NCP map that translates the center of the Bloch sphere to the coordinates {x0,y0,z0}.";*)
(*rotation::usage= "rotate[\[Theta],x,y,z] gives an arbitrary 2x2 rotation matrix for a qubit. The rotation is counter-clockwise about the unit vector {x,y,z} by an angle \[Theta].";*)
(*rot3::usage= "rot3[\[Theta],{r1,r2,r3}] gives an arbitrary 3D rotation about the unit axis {r1,r2,r3} by an angle \[Theta].";*)
(*fidelity::usage"fidelity[STATE1,STATE2] gives the quantum fidelity between two arbitrary single qubit states.";*)
(*entanglement::usage "entanglement[STATE] gives the square root of the eigenvalues of the operator \[Rho] \!\(\*SubscriptBox[\(\[Sigma]\), \(y\)]\)\[CircleTimes]\!\(\*SubscriptBox[\(\[Sigma]\), \(y\)]\) \!\(\*SuperscriptBox[\(\[Rho]\), \(T\)]\) \!\(\*SubscriptBox[\(\[Sigma]\), \(y\)]\)\[CircleTimes]\!\(\*SubscriptBox[\(\[Sigma]\), \(y\)]\).";*)
(**)
(*Begin["`Private`"] *)
(**)
(*pm[i_]:= PauliMatrix[i];*)
(*plus[\[Epsilon]_]:= Sqrt[Divide[1+\[Epsilon],2]]+Sqrt[Divide[1-\[Epsilon],2]];*)
(*minus[\[Epsilon]_]:= Sqrt[Divide[1+\[Epsilon],2]]-Sqrt[Divide[1-\[Epsilon],2]];*)
(*measure[\[Epsilon]_, x_,y_,z_]:= Divide[1,2](plus[\[Epsilon]]pm[0]+minus[\[Epsilon]]Divide[1,Sqrt[x^2+y^2+z^2]](x pm[1]+y pm[2]+z pm[3]));*)
(*pauli = {PauliMatrix[1],PauliMatrix[2],PauliMatrix[3]};*)
(*kp[i_,j_]:= KroneckerProduct[i,j];*)
(*pt1[{{a_,b_,c_,d_},{e_,f_,g_,h_},{i_,j_,k_,l_},{m_,n_,o_,p_}}]:= {{a+f,c+h},{i+n,k+p}};*)
(*pt2[{{a_,b_,c_,d_},{e_,f_,g_,h_},{i_,j_,k_,l_},{m_,n_,o_,p_}}]:= {{a+k,b+l},{e+o,f+p}}; *)
(*pTran[{{a_,b_,c_,d_},{e_,f_,g_,h_},{i_,j_,k_,l_},{m_,n_,o_,p_}}]:= {{a,e,c,g},{b,f,d,h},{i,m,k,o},{j,n,l,p}};*)
(*density[x_,y_,z_]:= Divide[1,2](PauliMatrix[0]+x PauliMatrix[1]+y PauliMatrix[2]+z PauliMatrix[3]);*)
(*bloch[state_]:={Tr[state . PauliMatrix[1]],Tr[state . PauliMatrix[2]],Tr[state . PauliMatrix[3]]};*)
(*a2b[{{a_,b_,c_,d_},{e_,f_,g_,h_},{i_,j_,k_,l_},{m_,n_,o_,p_}}]:= {{a,b,e,f},{c,d,g,h},{i,j,m,n},{k,l,o,p}};*)
(*d2v[{{a_,b_},{c_,d_}}]:= {{a},{b},{c},{d}};*)
(*v2d[{{a_},{b_},{c_},{d_}}]:= {{a,b},{c,d}};*)
(*d2vTwoQubit[state_]:= {{state[[1,1]]},{state[[1,2]]},{state[[2,1]]},{state[[2,2]]},{state[[1,3]]},{state[[1,4]]},{state[[2,3]]},{state[[2,4]]},{state[[3,1]]},{state[[3,2]]},{state[[4,1]]},{state[[4,2]]},{state[[3,3]]},{state[[3,4]]},{state[[4,3]]},{state[[4,4]]}};*)
(*v2dTwoQubit[state_]:= {{state[[1]]//Last,state[[2]]//Last,state[[5]]//Last,state[[6]]//Last},{state[[3]]//Last,state[[4]]//Last,state[[7]]//Last,state[[8]]//Last},{state[[9]]//Last,state[[10]]//Last,state[[13]]//Last,state[[14]]//Last},{state[[11]]//Last,state[[12]]//Last,state[[15]]//Last,state[[16]]//Last}};*)
(*vecShift[aMatrix_]:= {UnitVector[16,1],UnitVector[16,2],UnitVector[16,5],UnitVector[16,6],UnitVector[16,3],UnitVector[16,4],UnitVector[16,7],UnitVector[16,8],UnitVector[16,9],UnitVector[16,10],UnitVector[16,13],UnitVector[16,14],UnitVector[16,11],UnitVector[16,12],UnitVector[16,15],UnitVector[16,16]} . aMatrix . {UnitVector[16,1],UnitVector[16,2],UnitVector[16,5],UnitVector[16,6],UnitVector[16,3],UnitVector[16,4],UnitVector[16,7],UnitVector[16,8],UnitVector[16,9],UnitVector[16,10],UnitVector[16,13],UnitVector[16,14],UnitVector[16,11],UnitVector[16,12],UnitVector[16,15],UnitVector[16,16]};*)
(*convert[matrix_,dim_]:= ArrayReshape[Flatten[FlattenAt[Partition[matrix,{dim,dim}],ArrayReshape[Flatten[Table[{i,j,k},{i,1,dim},{j,1,dim},{k,1,dim}]],{dim^3,3}]]],{dim^2,dim^2}];*)
(*zz={{1,0},{0,0}};*)
(*zo={{0,1},{0,0}};*)
(*oz={{0,0},{1,0}};*)
(*oo={{0,0},{0,1}};*)
(*hadamard = Divide[1,Sqrt[2]]{{1,1},{1,-1}};*)
(*swap = {{1,0,0,0},{0,0,1,0},{0,1,0,0},{0,0,0,1}};*)
(*cnot12 = {{1,0,0,0},{0,1,0,0},{0,0,0,1},{0,0,1,0}};*)
(*cnot21 = {{1,0,0,0},{0,0,0,1},{0,0,1,0},{0,1,0,0}};*)
(*state[v1_,v2_,correlation_]:= Divide[1,4](IdentityMatrix[4]+KroneckerProduct[Dot[v1,{PauliMatrix[1],PauliMatrix[2],PauliMatrix[3]}],PauliMatrix[0]]+KroneckerProduct[PauliMatrix[0],Dot[v2,{PauliMatrix[1],PauliMatrix[2],PauliMatrix[3]}]]+Sum[correlation[[i,j]]KroneckerProduct[PauliMatrix[i],PauliMatrix[j]],{i,1,3},{j,1,3}]);*)
(*unitary[state_,unitary_]:= unitary . state . ConjugateTranspose[unitary];*)
(*cUnitary12[\[Theta]_,x_,y_,z_]:={{1,0,0,0},{0,1,0,0},{0,0,Cos[\[Theta]]-I z Sin[\[Theta]],(-I x-y) Sin[\[Theta]]},{0,0,(-I x+y) Sin[\[Theta]],Cos[\[Theta]]+I z Sin[\[Theta]]}};*)
(*cUnitary21[\[Theta]_,x_,y_,z_]:= {{Cos[\[Theta]]-I z Sin[\[Theta]],(-I x-y) Sin[\[Theta]],0,0},{(-I x+y) Sin[\[Theta]],Cos[\[Theta]]+I z Sin[\[Theta]],0,0},{0,0,1,0},{0,0,0,1}};*)
(*phiP= Divide[1,2]{{1,0,0,1},{0,0,0,0},{0,0,0,0},{1,0,0,1}};*)
(*phiM = Divide[1,2]{{1,0,0,-1},{0,0,0,0},{0,0,0,0},{-1,0,0,1}};*)
(*psiP = Divide[1,2]{{0,0,0,0},{0,1,1,0},{0,1,1,0},{0,0,0,0}};*)
(*psiM = Divide[1,2]{{0,0,0,0},{0,1,-1,0},{0,-1,1,0},{0,0,0,0}};*)
(*asym[\[Alpha]_,\[Beta]_,\[Gamma]_]:= {{1/2+\[Gamma]/2,0,0,1/2-\[Gamma]/2},{0,\[Alpha]/2+\[Beta]/2,\[Alpha]/2-\[Beta]/2,0},{0,\[Alpha]/2-\[Beta]/2,\[Alpha]/2+\[Beta]/2,0},{1/2-\[Gamma]/2,0,0,1/2+\[Gamma]/2}};*)
(*asymChannel[state_,x_,y_,z_]:= Divide[1,4]((1+x+y+z)state+ (1+x-y-z)PauliMatrix[1] . state . PauliMatrix[1]+(1-x+y-z)PauliMatrix[2] . state . PauliMatrix[2]+(1-x-y+z)PauliMatrix[3] . state . PauliMatrix[3]);*)
(*translate[x0_,y0_,z0_]:=Divide[1,2]{{2+z0,0,0,z0},{x0-I y0,2,0,x0-I y0},{x0+I y0,0,2,x0+I y0},{-z0,0,0,2-z0}};*)
(*rotation[\[Theta]_,x_,y_,z_]:= {{Cos[\[Theta]/2]-I z Sin[\[Theta]/2],(-I x-y) Sin[\[Theta]/2]},{(-I x+y) Sin[\[Theta]/2],Cos[\[Theta]/2]+I z Sin[\[Theta]/2]}};*)
(*rot3[\[Theta]_,{r1_,r2_,r3_}]:= Cos[\[Theta]]IdentityMatrix[3]+Sin[\[Theta]]Divide[1,Sqrt[{r1,r2,r3} . {r1,r2,r3}]]{{0,-r3,r2},{r3,0,-r1},{-r2,r1,0}}+(1-Cos[\[Theta]])Divide[1,{r1,r2,r3} . {r1,r2,r3}]KroneckerProduct[{r1,r2,r3},{r1,r2,r3}];*)
(*fidelity[state1_,state2_]:= Tr[state1 . state2]+2Sqrt[Det[state1]Det[state2]];*)
(*entanglement[state_]:= Sqrt[Eigenvalues[state . kp[pm[2],pm[2]] . Transpose[state] . kp[pm[2],pm[2]]]]; *)
(**)
(**)
(**)
(*End[]*)
(**)
(*EndPackage[]*)
